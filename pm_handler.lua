#!/usr/bin/env lua
-- -*-lua-*-
--
-- $Id: pm_handler.lua $
--
-- Author: Markus Stenberg <markus stenberg@iki.fi>
--
-- Copyright (c) 2012 cisco Systems, Inc.
--
-- Created:       Wed Nov  7 19:33:20 2012 mstenber
-- Last modified: Thu Oct 10 11:17:52 2013 mstenber
-- Edit time:     58 min
--

-- single pm handler prototype

require 'mst'
require 'mst_eventful'

local _eventful = mst_eventful.eventful

module('pm_handler', package.seeall)

-- first an abstract class that can be used to get information to a
-- handler
source = _eventful:new_subclass{class='source', mandatory={'parent'}}

-- by default, source is always ready
function source:ready()
   return true
end

function source:repr_data()
   return '?'
end


pm_handler = _eventful:new_subclass{class='pm_handler', 
                                    mandatory={'_pm'},
                                    events={'changed'},
                                    sources={}}

function pm_handler:repr_data()
   return '?'
end

function pm_handler:init()
   _eventful.init(self)
   self.file_contents = {}
   self.shell = self._pm.shell
   for i, s in ipairs(self.sources)
   do
      self._sources = self._sources or {}
      self._sources[s:new{parent=self}] = s
   end
end

function pm_handler:uninit()
   for k, v in pairs(self._sources or {})
   do
      k:done()
   end
end

function pm_handler:queue()
   local old = self.queued
   self.queued = true
   return not old
end

function pm_handler:ready()
   for k, v in pairs(self._sources or {})
   do
      if not k:ready()
      then
         return false
      end
   end
   return true
end

function pm_handler:maybe_tick()
   if not self.tick
   then
      return
   end
   if not self:ready()
   then
      return
   end
   return self:tick()
end

function pm_handler:maybe_run()
   if not self.queued
   then
      --self:d(' not queued')
      return
   end

   -- if not ready, not going to do a thing
   self:d('maybe_run')

   if not self:ready()
   then
      self:d(' not ready')
      return
   end
   self.queued = nil
   local v = self:run()
   if v and v > 0
   then
      self:changed()
   end
end

function pm_handler:run()
   -- REALLY implemented by the children
end

function pm_handler:time()
   return self._pm:time()
end

function pm_handler:write_to_file(fpath, t0, comment_prefix)
   local t = mst.array:new()
   local s0 = table.concat(t0, '\n')
   if comment_prefix
   then
      t:insert(comment_prefix)
      t:insert(comment_prefix .. fpath)
      t:insert(comment_prefix .. 
               'automatically generated by ' .. self.class .. 
               ' on ' .. os.date())
      t:insert(comment_prefix)
   end
   t:insert(s0)
   t:insert('')
   local s = t:join('\n')
   if self.file_contents[fpath] == s0
   then
      return
   end
   self.file_contents[fpath] = s0

   local f, err = io.open(fpath, 'w')
   self:a(f, 'unable to open for writing', fpath, err)
   f:write(s)
   -- close the file
   io.close(f)
   return true
end

-- openwrt-specific utilities (used only in pm_netifd_*)

function pm_handler:get_uci_cursor()
   require 'uci'
   return uci.cursor()
end

function pm_handler:get_uci_cursor()
   require 'uci'
   return uci.cursor()
end

function pm_handler:get_ubus_connection()
   require 'ubus'
   return ubus.connect()
end

-- openwrt-specific subclass

ni_source = source:new_subclass{class='ni_source'}

function ni_source:init()
   self:connect_method(self.parent._pm.network_interface_changed, 
                       self.ni_changed)
end

function ni_source:ni_changed(ni)
   self:d('ni_changed')
   self.parent.ni = ni
   self.parent:queue()
end

function ni_source:ready()
   return self.parent.ni
end

pm_handler_with_ni = pm_handler:new_subclass{class='pm_handler_with_ni',
                                             sources={ni_source}}


pa_source = source:new_subclass{class='pa_source'}

function pa_source:init()
   -- then connect to relevant change notifications we're interested about
   self:connect_method(self.parent._pm.usp_changed, self.usp_changed)
   self:connect_method(self.parent._pm.lap_changed, self.lap_changed)
end

function pa_source:usp_changed(usp)
   self.parent.usp = usp
   self.parent:queue()
end

function pa_source:lap_changed(lap)
   self.parent.lap = lap
   self.parent:queue()
end

function pa_source:ready()
   return self.parent.usp and self.parent.lap
end


skv_source = source:new_subclass{class='skv_source'}

function skv_source:init()
   self:connect_method(self.parent._pm.skv_changed, self.skv_changed)
end

function skv_source:skv_changed(k, v)
   -- just proxy skv_changed to parent
   self.parent:skv_changed(k, v)
end

pm_handler_with_pa = pm_handler:new_subclass{class='pm_handler_with_pa',
                                             sources={pa_source,
                                                      skv_source}}

function pm_handler_with_pa:get_if_table()
   if not self.if_table
   then
      -- shared datastructures
      self.if_table = linux_if.if_table:new{shell=self.shell} 
   end
   return self.if_table
end


function pm_handler_with_pa:skv_changed(k, v)
   -- nop
end

pm_handler_with_pa_dns = pm_handler_with_pa:new_subclass{class='pm_handler_with_pa_dns'}

function pm_handler_with_pa_dns:skv_changed(k, v)
   if k == elsa_pa.OSPF_IPV4_DNS_KEY
   then
      self.ospf_v4_dns = v or {}
   elseif k == elsa_pa.OSPF_IPV4_DNS_SEARCH_KEY
   then
      self.ospf_v4_dns_search = v or {}
   elseif k == elsa_pa.OSPF_DNS_KEY
   then
      self.ospf_dns = v or {}
   elseif k == elsa_pa.OSPF_DNS_SEARCH_KEY
   then
      self.ospf_dns_search = v or {}
   elseif k == elsa_pa.HP_SEARCH_LIST_KEY
   then
      self.hp_search = v or {}
   else
      return
   end
   self:queue()
end

